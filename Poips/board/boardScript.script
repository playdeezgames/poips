local maze = require("Maze.Maze")
local mazeGenerator = require("Maze.MazeGenerator")
local mazeDirections = require("Maze.MazeDirections")
local options = require("utilities.options")

local BOARD_COLUMNS = 16
local BOARD_ROWS = 16
local DIRECTION_NORTH = 1
local DIRECTION_EAST = 2
local DIRECTION_SOUTH = 3
local DIRECTION_WEST = 4

local directionFlags = {1,2,4,8}
local opposite = {3,4,1,2}
local deltaX = {0,1,0,-1}
local deltaY = {1,0,-1,0}

local board = {}
for column=1,BOARD_COLUMNS do
	board[column]={}
	for row = 1, BOARD_ROWS do
		board[column][row]={flags={false,false,false,false},lit=false,locked=false}
	end
end
local cursorColumn=1
local cursorRow=1
local originColumn=1
local originRow=1
local moves = 0
local gameTime = 0
local inPlay = false
local titleShowing = true
local needsReset = true;

function rotateCellCCW(column, row)
	local boardCell = board[column][row]
	if not boardCell.locked then
		local flag = table.remove(boardCell.flags,1)
		table.insert(boardCell.flags, flag)
	end
end

function rotateCellCW(column,row)
	rotateCellCCW(column,row)
	rotateCellCCW(column,row)
	rotateCellCCW(column,row)
end

function unlight(column,row)
	local boardCell = board[column][row]
	if boardCell.lit then
		boardCell.lit = false
		for direction = DIRECTION_NORTH, DIRECTION_WEST do
			if boardCell.flags[direction] then
				local nextColumn = column + deltaX[direction]
				local nextRow = row + deltaY[direction]
				if nextColumn>=1 and nextColumn<=BOARD_COLUMNS and nextRow>=1 and nextRow<=BOARD_ROWS then
					local nextCell = board[nextColumn][nextRow]
					if nextCell.flags[opposite[direction]] then
						unlight(nextColumn, nextRow)
					end
				end
			end
		end
	end
end
	
function light(column,row)
	local boardCell = board[column][row]
	if not boardCell.lit then
		boardCell.lit = true
		for direction = DIRECTION_NORTH, DIRECTION_WEST do
			if boardCell.flags[direction] then
				local nextColumn = column + deltaX[direction]
				local nextRow = row + deltaY[direction]
				if nextColumn>=1 and nextColumn<=BOARD_COLUMNS and nextRow>=1 and nextRow<=BOARD_ROWS then
					local nextCell = board[nextColumn][nextRow]
					if nextCell.flags[opposite[direction]] then
						light(nextColumn, nextRow)
					end
				end
			end
		end
	end
end

function toggleLock(column,row)
	sound.play("#lock")
	local boardCell = board[column][row]
	boardCell.locked = not boardCell.locked
end

function scrambleBoard()
	for column=1,BOARD_COLUMNS do
		for row=1,BOARD_ROWS do
			local boardCell = board[column][row]
			local tally = 0
			for direction=DIRECTION_NORTH,DIRECTION_WEST do
				if boardCell.flags[direction] then
					tally = tally + 1
				end
			end
			if tally==4 or tally==0 then
				boardCell.locked=true
			elseif tally == 3 or tally==1 then
				local turns = math.random(1,3)
				for turn=1,turns do
					rotateCellCCW(column, row)
				end
			else
				for direction=DIRECTION_NORTH,DIRECTION_WEST do
					boardCell.flags[direction] = not boardCell.flags[direction]
				end
			end
		end
	end
end

function resetBoard()
	local m = maze.new(BOARD_COLUMNS, BOARD_ROWS, mazeDirections)
	mazeGenerator.generate(m, mazeDirections)
	for column=1,BOARD_COLUMNS do
		for row=1,BOARD_ROWS do
			local mazeCell = m:getCell(column,row)
			local boardCell = board[column][row]
			for direction=DIRECTION_NORTH,DIRECTION_WEST do
				boardCell.flags[direction]=mazeCell:hasNeighbor(direction) and mazeCell:getDoor(direction):isOpen()
				boardCell.lit = false
				boardCell.locked = false
			end
		end
	end
	originColumn = math.random(1,BOARD_COLUMNS)
	originRow = math.random(1,BOARD_ROWS)
	scrambleBoard()
	light(originColumn, originRow)
	moves = 0
	gameTime = 0
end

local frameTime = os.clock()

function init(self)
	options.loadOptions()
	if sound.get_group_gain("master")>0 then
		sprite.play_flipbook("/title/buttons#settingsbutton", "SpeakerOn")
	else
		sprite.play_flipbook("/title/buttons#settingsbutton", "SpeakerOn")
	end
	sound.play("#music")
	math.randomseed(os.time())
	resetBoard()
	msg.post(".", "acquire_input_focus")
	msg.post("/title/win", "disable")
end

function update(self, dt)
	local currentTime = os.clock()
	local deltaTime = currentTime - frameTime
	frameTime = currentTime
	if inPlay then
		gameTime = gameTime + deltaTime
	end
	for column=1,BOARD_COLUMNS do
		for row=1,BOARD_ROWS do
			local boardCell = board[column][row]
			local tile = 1
			for direction = DIRECTION_NORTH, DIRECTION_WEST do
				if boardCell.flags[direction] then
					tile = tile + directionFlags[direction]
				end
			end
			if column==cursorColumn and row == cursorRow then
				tile = tile + 16
			end
			tilemap.set_tile("#board","foreground", column, row, tile)
			tile = 33
			if column==originColumn and row==originRow then
				tile = tile + 1
			elseif boardCell.lit then
				tile = tile + 2
			end
			if boardCell.locked then
				tile = tile + 3
			end
			tilemap.set_tile("#board","background", column, row, tile)
		end
	end
	local temp = moves
	local column = BOARD_COLUMNS
	for digits=1,5 do
		local tile = temp % 10 + 39
		temp = math.floor(temp/10)
		tilemap.set_tile("#board","background", column, BOARD_ROWS+1, tile)
		column = column - 1
	end
	temp = math.floor(gameTime)
	local column = BOARD_COLUMNS
	for digits=1,5 do
		local tile = temp % 10 + 39
		temp = math.floor(temp/10)
		tilemap.set_tile("#board","background", column, BOARD_ROWS+2, tile)
		column = column - 1
	end
end

function hideTitle()
	msg.post("/title/fade", "disable")
	msg.post("/title/clicktostart", "disable")
	msg.post("/title/poips", "disable")
	msg.post("/title/win", "disable")
	msg.post("/title/buttons", "disable")
	titleShowing = false
	resetBoard()
end

function toggleMute()
	sound.set_group_gain("master", 1-sound.get_group_gain("master"))
	options.saveOptions()
end

function doWinCheck()
	for column=1,BOARD_COLUMNS do
		for row=1,BOARD_ROWS do
			local boardCell = board[column][row]
			if not boardCell.lit then
				return false
			end
		end
	end
	return true
end

function makeMove(moveMaker)
	if not board[cursorColumn][cursorRow].locked then
		unlight(originColumn,originRow)
		moveMaker(cursorColumn,cursorRow)
		sound.play("#turn")
		moves = moves + 1
		inPlay = true
		light(originColumn,originRow)
		if doWinCheck() then
			msg.post("/title/buttons", "enable")
			msg.post("/title/fade", "enable")
			msg.post("/title/clicktostart", "enable")
			msg.post("/title/win", "enable")
			titleShowing = true
			inPlay=false		
		end
	end
end

function handleTitleClick()
	if cursorColumn>=1 and cursorColumn<=2 and cursorRow>=1 and cursorRow<=2 then
	elseif cursorColumn>=BOARD_COLUMNS-1 and cursorColumn<=BOARD_COLUMNS and cursorRow>=1 and cursorRow<=2 then
	elseif cursorColumn>=1 and cursorColumn<=2 and cursorRow>=BOARD_ROWS-1 and cursorRow<=BOARD_ROWS then
		toggleMute()
	elseif cursorColumn>=BOARD_COLUMNS-1 and cursorColumn<=BOARD_COLUMNS and cursorRow>=BOARD_ROWS-1 and cursorRow<=BOARD_ROWS then
	else
		hideTitle()
	end
end

function handleTitleHover()
	if cursorColumn>=1 and cursorColumn<=2 and cursorRow>=1 and cursorRow<=2 then
		sprite.play_flipbook("/title/buttons#helpbutton", "HelpHover")
	else
		sprite.play_flipbook("/title/buttons#helpbutton", "Help")
	end
	if cursorColumn>=BOARD_COLUMNS-1 and cursorColumn<=BOARD_COLUMNS and cursorRow>=1 and cursorRow<=2 then
		sprite.play_flipbook("/title/buttons#infobutton", "InfoHover")
	else
		sprite.play_flipbook("/title/buttons#infobutton", "Info")
	end
	if cursorColumn>=1 and cursorColumn<=2 and cursorRow>=BOARD_ROWS-1 and cursorRow<=BOARD_ROWS then
		if sound.get_group_gain("master")>0 then
			sprite.play_flipbook("/title/buttons#settingsbutton", "SpeakerOffHover")
		else
			sprite.play_flipbook("/title/buttons#settingsbutton", "SpeakerOnHover")
		end
	else
		if sound.get_group_gain("master")>0 then
			sprite.play_flipbook("/title/buttons#settingsbutton", "SpeakerOff")
		else
			sprite.play_flipbook("/title/buttons#settingsbutton", "SpeakerOn")
		end
	end
	if cursorColumn>=BOARD_COLUMNS-1 and cursorColumn<=BOARD_COLUMNS and cursorRow>=BOARD_ROWS-1 and cursorRow<=BOARD_ROWS then
		sprite.play_flipbook("/title/buttons#statsbutton", "StatsHover")
	else
		sprite.play_flipbook("/title/buttons#statsbutton", "Stats")
	end
end

function on_input(self, action_id, action)
	if action_id==nil then
		cursorColumn=math.floor(action.x/32)+1
		cursorRow=math.floor(action.y/32)+1
		handleTitleHover()
	elseif action_id==hash("previous") and action.pressed then
		if titleShowing then
			handleTitleClick()
		else
			makeMove(rotateCellCCW)
		end
	elseif action_id==hash("mute") and action.pressed then
		toggleMute()
	elseif action_id==hash("next") and action.pressed then
		if titleShowing then
			handleTitleClick()
		else
			makeMove(rotateCellCW)
		end
	elseif action_id==hash("green") and action.pressed then
		if titleShowing then
			handleTitleClick()
		else
			toggleLock(cursorColumn, cursorRow)
		end
	end
end
